# Deploy docs preview to Cloudflare when PRs pass build and are labeled
name: Deploy Docs Preview

on:
  pull_request_target:
    types: [labeled, synchronize]

# Ensure only one deploy per PR runs at a time
concurrency:
  group: docs-staging-${{ github.event.pull_request.number || 'manual' }}
  cancel-in-progress: true

env:
  PREVIEW_LABEL: preview

jobs:
  resolve_pr:
    name: Resolve PR and preview label
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: write
    outputs:
      should_deploy: ${{ steps.evaluate.outputs.should_deploy }}
      pr_number: ${{ steps.evaluate.outputs.pr_number }}
      pr_sha: ${{ steps.evaluate.outputs.pr_sha }}
      pr_ref: ${{ steps.evaluate.outputs.pr_ref }}
      pr_repo: ${{ steps.evaluate.outputs.pr_repo }}
      skip_reason: ${{ steps.evaluate.outputs.skip_reason }}
    env:
      MANUAL_PR_NUMBER: ${{ inputs.pr_number || '' }}
      PREVIEW_TEAM_SLUG: ${{ vars.DOCS_PREVIEW_TEAM_SLUG || '' }}
      PREVIEW_ALLOWED_USERS: ${{ vars.DOCS_PREVIEW_ALLOWED_USERS || '' }}
    steps:
      - name: Evaluate deployment eligibility
        id: evaluate
        uses: actions/github-script@v7
        with:
          script: |
            const previewLabel = process.env.PREVIEW_LABEL || 'preview';
            const manualPr = process.env.MANUAL_PR_NUMBER;
            const teamSlug = (process.env.PREVIEW_TEAM_SLUG || '').trim();
            const allowedList = (process.env.PREVIEW_ALLOWED_USERS || '')
              .split(',')
              .map((value) => value.trim())
              .filter(Boolean);
            const eventName = context.eventName;

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const outputs = {
              should_deploy: 'false',
              pr_number: '',
              pr_sha: '',
              pr_ref: '',
              pr_repo: '',
              skip_reason: '',
            };

            const restrictionsEnabled = allowedList.length > 0 || !!teamSlug;

            async function isActorAllowed(username) {
              if (!username) {
                return false;
              }

              if (!restrictionsEnabled) {
                return true;
              }

              if (allowedList.includes(username)) {
                return true;
              }

              if (!teamSlug) {
                return false;
              }

              try {
                const membership = await github.rest.teams.getMembershipForUserInOrg({
                  org: owner,
                  team_slug: teamSlug,
                  username,
                });

                return membership?.data?.state === 'active';
              } catch (error) {
                if (error.status === 404) {
                  return false;
                }

                core.warning(`Unable to verify team membership for ${username}: ${error.message}`);
                return false;
              }
            }

            function setOutputs(details) {
              for (const [key, value] of Object.entries(details)) {
                core.setOutput(key, value ?? '');
              }
            }

            function complete(details) {
              setOutputs(details);
              return;
            }

            let prNumber;
            let pr;

            if (eventName === 'workflow_dispatch') {
              if (!manualPr) {
                return complete({
                  ...outputs,
                  skip_reason: 'Manual dispatch requires a PR number.',
                });
              }

              prNumber = Number(manualPr);
              try {
                const { data } = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: prNumber,
                });
                pr = data;
              } catch (error) {
                return complete({
                  ...outputs,
                  skip_reason: `Unable to load PR #${manualPr}: ${error.message}`,
                });
              }

              if (!pr || pr.state !== 'open') {
                return complete({
                  ...outputs,
                  skip_reason: `PR #${prNumber} is not open.`,
                  pr_number: prNumber?.toString() ?? '',
                });
              }

              return complete({
                should_deploy: 'true',
                pr_number: pr.number.toString(),
                pr_sha: pr.head.sha,
                pr_ref: pr.head.ref,
                pr_repo: pr.head.repo.full_name,
                skip_reason: '',
              });
            }

            if (eventName === 'pull_request_target') {
              pr = context.payload.pull_request;
              prNumber = pr?.number;
            } else {
              return complete({
                ...outputs,
                skip_reason: `Event ${eventName} is not supported.`,
              });
            }

            if (!prNumber || !pr) {
              return complete({
                ...outputs,
                skip_reason: 'Unable to resolve pull request context.',
              });
            }

            const result = {
              should_deploy: 'false',
              pr_number: pr.number.toString(),
              pr_sha: pr.head.sha,
              pr_ref: pr.head.ref,
              pr_repo: pr.head.repo.full_name,
              skip_reason: '',
            };

            if (pr.state !== 'open') {
              return complete({
                ...result,
                skip_reason: `PR #${pr.number} is not open.`,
              });
            }

            const hasPreviewLabel = pr.labels.some((label) => label.name === previewLabel);

            if (context.payload?.action === 'synchronize') {
              const syncActor = context.payload?.sender?.login ?? null;

              if (!syncActor) {
                return complete({
                  ...result,
                  skip_reason: 'Unable to determine the actor that pushed the latest commits.',
                });
              }

              const syncActorAllowed = await isActorAllowed(syncActor);

              if (!syncActorAllowed) {
                if (hasPreviewLabel) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner,
                      repo,
                      issue_number: pr.number,
                      name: previewLabel,
                    });
                    core.info(`Removed '${previewLabel}' label after unauthorized synchronize by @${syncActor}.`);
                  } catch (error) {
                    if (error.status !== 404) {
                      core.warning(`Failed to remove '${previewLabel}' label: ${error.message}`);
                    }
                  }

                  try {
                    await github.rest.issues.createComment({
                      owner,
                      repo,
                      issue_number: pr.number,
                      body: `Preview label removed: new commits from @${syncActor} are not permitted to trigger docs preview deployments. A team member can re-apply the \`${previewLabel}\` label once the changes are ready.`,
                    });
                  } catch (error) {
                    core.warning(`Failed to comment about preview label removal: ${error.message}`);
                  }
                }

                return complete({
                  ...result,
                  skip_reason: `Preview deployment blocked: @${syncActor} is not authorized to trigger deployments.`,
                });
              }
            }

            if (!hasPreviewLabel) {
              return complete({
                ...result,
                skip_reason: `PR #${pr.number} does not have the '${previewLabel}' label.`,
              });
            }

            let actor = null;
            if (context.payload?.action === 'labeled' && context.payload?.label?.name === previewLabel) {
              actor = context.payload?.sender?.login ?? null;
            }

            if (!actor) {
              try {
                const events = await github.paginate(github.rest.issues.listEvents, {
                  owner,
                  repo,
                  issue_number: pr.number,
                  per_page: 100,
                });

                for (const event of events.reverse()) {
                  if (!event.label || event.label.name !== previewLabel) {
                    continue;
                  }

                  if (event.event === 'labeled') {
                    actor = event.actor?.login ?? null;
                    break;
                  }

                  if (event.event === 'unlabeled') {
                    actor = null;
                    break;
                  }
                }
              } catch (error) {
                core.warning(`Unable to inspect label history: ${error.message}`);
              }
            }

            if (!actor) {
              return complete({
                ...result,
                skip_reason: `Unable to determine who last applied the '${previewLabel}' label.`,
              });
            }

            const actorAllowed = await isActorAllowed(actor);
            if (!actorAllowed) {
              return complete({
                ...result,
                skip_reason: `@${actor} is not allowed to apply the '${previewLabel}' label.`,
              });
            }

            return complete({
              ...result,
              should_deploy: 'true',
            });

  skip_notice:
    name: Preview deploy skipped
    runs-on: ubuntu-latest
    needs: resolve_pr
    if: needs.resolve_pr.outputs.should_deploy != 'true'
    steps:
      - run: |
          echo "Preview deploy skipped: ${{ needs.resolve_pr.outputs.skip_reason || 'No deployment conditions met.' }}"

  deploy_docs_staging:
    name: Deploy PR #${{ needs.resolve_pr.outputs.pr_number }} to staging
    needs: resolve_pr
    if: needs.resolve_pr.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest

    # THIS is the gate. In repo Settings → Environments → 'staging', require approval from Owners/Admins.
    environment:
      name: staging

    permissions:
      contents: read
      deployments: write
      issues: write
      pull-requests: write

    env:
      SEARCH_MODE: ${{ secrets.SEARCH_MODE }}
      PR_NUMBER: ${{ needs.resolve_pr.outputs.pr_number }}
      PR_SHA: ${{ needs.resolve_pr.outputs.pr_sha }}
      PR_REF: ${{ needs.resolve_pr.outputs.pr_ref }}
      PR_REPO: ${{ needs.resolve_pr.outputs.pr_repo }}
      PREVIEW_DEPLOY_ENVIRONMENT: docs-preview-pr-${{ needs.resolve_pr.outputs.pr_number }}
      # Cloudflare configuration (recommend storing these as Environment secrets on 'staging')
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
      CF_STAGING_WORKER_NAME: ${{ secrets.CF_STAGING_WORKER_NAME }}
      DOCS_SLACK_FEEDBACK_WEBHOOK: ${{ secrets.DOCS_SLACK_FEEDBACK_WEBHOOK }}
      DOCS_NEXT_PUBLIC_MESH_SDK_KEY: ${{ secrets.DOCS_NEXT_PUBLIC_MESH_SDK_KEY }}
      DOCS_NEXT_PUBLIC_UNIFY_SCRIPT_SRC: ${{ secrets.DOCS_NEXT_PUBLIC_UNIFY_SCRIPT_SRC }}
      DOCS_NEXT_PUBLIC_UNIFY_API_KEY: ${{ secrets.DOCS_NEXT_PUBLIC_UNIFY_API_KEY }}
      DOCS_NEXT_PUBLIC_RB2B_KEY: ${{ secrets.DOCS_NEXT_PUBLIC_RB2B_KEY }}
      NEXT_PUBLIC_PYLON_APP_ID: ${{ secrets.NEXT_PUBLIC_PYLON_APP_ID }}
      PYLON_IDENTITY_SECRET: ${{ secrets.PYLON_IDENTITY_SECRET }}

    steps:
      - uses: actions/checkout@v4
        with:
          # Support forks by checking out the PR's head repo/ref explicitly
          repository: ${{ env.PR_REPO }}
          ref: ${{ env.PR_SHA }}
          submodules: true

      - name: Install Bun
        uses: oven-sh/setup-bun@v2

      - name: Use Node.js 20.x
        uses: actions/setup-node@v4
        with:
          node-version: 20.18.1

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Create GitHub Deployment
        id: create_deployment
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          environment: ${{ env.PREVIEW_DEPLOY_ENVIRONMENT }}
          ref: ${{ env.PR_SHA }}

      - name: Mark deployment in progress
        uses: chrnorm/deployment-status@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          deployment-id: ${{ steps.create_deployment.outputs.deployment_id }}
          state: in_progress

      - name: Generate production env file
        run: |
          cat <<EOF > .env.production
          NEXTJS_ENV=production
          SLACK_FEEDBACK_WEBHOOK=${DOCS_SLACK_FEEDBACK_WEBHOOK}
          NEXT_PUBLIC_MESH_SDK_KEY=${DOCS_NEXT_PUBLIC_MESH_SDK_KEY}
          NEXT_PUBLIC_UNIFY_SCRIPT_SRC=${DOCS_NEXT_PUBLIC_UNIFY_SCRIPT_SRC}
          NEXT_PUBLIC_UNIFY_API_KEY=${DOCS_NEXT_PUBLIC_UNIFY_API_KEY}
          NEXT_PUBLIC_RB2B_KEY=${DOCS_NEXT_PUBLIC_RB2B_KEY}
          SEARCH_MODE=${SEARCH_MODE}
          NEXT_PUBLIC_PYLON_APP_ID=${NEXT_PUBLIC_PYLON_APP_ID}
          PYLON_IDENTITY_SECRET=${PYLON_IDENTITY_SECRET}
          EOF

      - name: Generate Wrangler config for CI
        run: |
          cat <<EOF > wrangler.jsonc
          {
            "$schema": "node_modules/wrangler/config-schema.json",
            "account_id": "${CF_ACCOUNT_ID}",
            "main": ".open-next/worker.js",
            "name": "${CF_STAGING_WORKER_NAME}",
            "compatibility_date": "2024-12-30",
            "compatibility_flags": [
              "nodejs_compat",
              "global_fetch_strictly_public"
            ],
            "assets": {
              "directory": ".open-next/assets",
              "binding": "ASSETS"
            },
            "services": [{
              "binding": "WORKER_SELF_REFERENCE",
              "service": "${CF_STAGING_WORKER_NAME}"
            }],
            "routes": [],
            "env": {
              "staging": {
                "workers_dev": true,
                "routes": []
              }
            }
          }
          EOF

      - name: Build and deploy with preview alias
        id: deploy
        env:
          PR: ${{ env.PR_NUMBER }}
        run: |
          set -e
          bun run build
          bunx opennextjs-cloudflare build --config wrangler.jsonc -- --skipNextBuild
          OUTPUT=$(npx wrangler@4.34.0 --config wrangler.jsonc versions upload --name ${CF_STAGING_WORKER_NAME} --preview-alias pr-$PR)
          echo "$OUTPUT"
          # Extract deployment URL
          DEPLOYMENT_URL=$(echo "$OUTPUT" | grep -oE 'https://[^ ]+\.workers\.dev' | head -1)
          # Extract alias URL
          ALIAS_URL=$(echo "$OUTPUT" | grep -oE 'https://pr-[0-9]+-[^ ]+\.workers\.dev' | head -1)
          if [ -z "$ALIAS_URL" ] && [ -n "$DEPLOYMENT_URL" ]; then
            DEPLOYMENT_HOST=$(echo "$DEPLOYMENT_URL" | sed -E 's#https?://([^/]+)/?#\1#')
            WORKER_NAME="${DEPLOYMENT_HOST%%.*}"
            ACCOUNT_DOMAIN="${DEPLOYMENT_HOST#*.}"
            if [ -n "$ACCOUNT_DOMAIN" ] && [ "$ACCOUNT_DOMAIN" != "$DEPLOYMENT_HOST" ]; then
              ALIAS_URL="https://pr-$PR-$WORKER_NAME.$ACCOUNT_DOMAIN"
            fi
          fi
          if [ -z "$ALIAS_URL" ]; then
            ALIAS_URL="https://pr-$PR-${CF_STAGING_WORKER_NAME}.${{ secrets.CF_WORKERS_SUBDOMAIN }}.workers.dev"
          fi
          echo "alias_url=$ALIAS_URL" >> $GITHUB_OUTPUT
          if [ -n "$DEPLOYMENT_URL" ]; then
            echo "deployment_url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          fi

      - name: Choose environment URL
        id: envurl
        env:
          ALIAS: ${{ steps.deploy.outputs.alias_url }}
          DEPLOYMENT: ${{ steps.deploy.outputs.deployment_url }}
        run: |
          URL="$ALIAS"
          if [ -z "$URL" ]; then
            URL="$DEPLOYMENT"
          fi
          echo "url=${URL}/docs/home" >> $GITHUB_OUTPUT

      - name: Update Deployment Status (success)
        if: success()
        uses: chrnorm/deployment-status@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          deployment-id: ${{ steps.create_deployment.outputs.deployment_id }}
          state: success
          environment-url: ${{ steps.envurl.outputs.url }}

      - name: Update Deployment Status (failure)
        if: failure()
        uses: chrnorm/deployment-status@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          deployment-id: ${{ steps.create_deployment.outputs.deployment_id }}
          state: failure

      - name: Update Deployment Status (cancelled)
        if: cancelled()
        uses: chrnorm/deployment-status@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          deployment-id: ${{ steps.create_deployment.outputs.deployment_id }}
          state: inactive

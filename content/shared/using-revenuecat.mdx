---
title: "Using RevenueCat"
description: "If you want to use RevenueCat to handle your subscription-related logic with Superwall, follow this guide."
---

<Note>
  Not using RevenueCat? No problem! Superwall works out of the box without any additional SDKs.
</Note>

You can integrate RevenueCat with Superwall using several approaches:

1. [**Using a purchase controller:**](#using-a-purchase-controller) Use this route if you want to maintain control over purchasing logic and code.
2. [**Using PurchasesAreCompletedBy:**](#using-purchasesarecompletedby) Here, you don't use a purchase controller and you tell RevenueCat that purchases are completed by your app using StoreKit. In this mode, RevenueCat will observe the purchases that the Superwall SDK makes. For more info [see here](https://www.revenuecat.com/docs/migrating-to-revenuecat/sdk-or-not/finishing-transactions).

## Using a purchase controller

### 1. Create a `PurchaseController`

Create a new file called `RCPurchaseController`, then copy and paste the following:

:::ios
```swift
import SuperwallKit
import RevenueCat
import StoreKit

enum PurchasingError: LocalizedError {
  case sk2ProductNotFound

  var errorDescription: String? {
    switch self {
    case .sk2ProductNotFound:
      return "Superwall didn't pass a StoreKit 2 product to purchase. Are you sure you're not "
        + "configuring Superwall with a SuperwallOption to use StoreKit 1?"
    }
  }
}

final class RCPurchaseController: PurchaseController {
  // MARK: Sync Subscription Status
  /// Makes sure that Superwall knows the customer's entitlements by
  /// changing `Superwall.shared.entitlements`
  func syncSubscriptionStatus() {
    assert(Purchases.isConfigured, "You must configure RevenueCat before calling this method.")
    Task {

      for await customerInfo in Purchases.shared.customerInfoStream {
        // Gets called whenever new CustomerInfo is available
        let superwallEntitlements = customerInfo.entitlements.activeInCurrentEnvironment.keys.map {
          Entitlement(id: $0)
        }
        await MainActor.run { [superwallEntitlements] in
          Superwall.shared.subscriptionStatus = .active(Set(superwallEntitlements))
        }
      }
    }
  }

  // MARK: Handle Purchases
  /// Makes a purchase with RevenueCat and returns its result. This gets called when
  /// someone tries to purchase a product on one of your paywalls.
  func purchase(product: SuperwallKit.StoreProduct) async -> PurchaseResult {
    do {
      guard let sk2Product = product.sk2Product else {
        throw PurchasingError.sk2ProductNotFound
      }
      let storeProduct = RevenueCat.StoreProduct(sk2Product: sk2Product)
      let revenueCatResult = try await Purchases.shared.purchase(product: storeProduct)
      if revenueCatResult.userCancelled {
        return .cancelled
      } else {
        return .purchased
      }
    } catch let error as ErrorCode {
      if error == .paymentPendingError {
        return .pending
      } else {
        return .failed(error)
      }
    } catch {
      return .failed(error)
    }
  }

  // MARK: Handle Restores
  /// Makes a restore with RevenueCat and returns `.restored`, unless an error is thrown.
  /// This gets called when someone tries to restore purchases on one of your paywalls.
  func restorePurchases() async -> RestorationResult {
    do {
      _ = try await Purchases.shared.restorePurchases()
      return .restored
    } catch let error {
      return .failed(error)
    }
  }
}
```
:::

:::android
```kotlin
package com.superwall.superapp

import android.app.Activity
import android.content.Context
import com.android.billingclient.api.ProductDetails
import com.revenuecat.purchases.CustomerInfo
import com.revenuecat.purchases.LogLevel
import com.revenuecat.purchases.ProductType
import com.revenuecat.purchases.PurchaseParams
import com.revenuecat.purchases.Purchases
import com.revenuecat.purchases.PurchasesConfiguration
import com.revenuecat.purchases.PurchasesError
import com.revenuecat.purchases.PurchasesErrorCode
import com.revenuecat.purchases.getCustomerInfoWith
import com.revenuecat.purchases.interfaces.GetStoreProductsCallback
import com.revenuecat.purchases.interfaces.PurchaseCallback
import com.revenuecat.purchases.interfaces.ReceiveCustomerInfoCallback
import com.revenuecat.purchases.interfaces.UpdatedCustomerInfoListener
import com.revenuecat.purchases.models.StoreProduct
import com.revenuecat.purchases.models.StoreTransaction
import com.revenuecat.purchases.models.SubscriptionOption
import com.revenuecat.purchases.models.googleProduct
import com.revenuecat.purchases.purchaseWith
import com.superwall.sdk.Superwall
import com.superwall.sdk.delegate.PurchaseResult
import com.superwall.sdk.delegate.RestorationResult
import com.superwall.sdk.delegate.subscription_controller.PurchaseController
import com.superwall.sdk.models.entitlements.Entitlement
import com.superwall.sdk.models.entitlements.SubscriptionStatus
import kotlinx.coroutines.CompletableDeferred

suspend fun Purchases.awaitProducts(productIds: List<String>): List<StoreProduct> {
    val deferred = CompletableDeferred<List<StoreProduct>>()
    getProducts(
        productIds,
        object : GetStoreProductsCallback {
            override fun onReceived(storeProducts: List<StoreProduct>) {
                deferred.complete(storeProducts)
            }

            override fun onError(error: PurchasesError) {
                deferred.completeExceptionally(Exception(error.message))
            }
        },
    )
    return deferred.await()
}

interface PurchaseCompletion {
    var storeTransaction: StoreTransaction
    var customerInfo: CustomerInfo
}

// Create a custom exception class that wraps PurchasesError
private class PurchasesException(
    val purchasesError: PurchasesError,
) : Exception(purchasesError.toString())

suspend fun Purchases.awaitPurchase(
    activity: Activity,
    storeProduct: StoreProduct,
): PurchaseCompletion {
    val deferred = CompletableDeferred<PurchaseCompletion>()
    purchase(
        PurchaseParams.Builder(activity, storeProduct).build(),
        object : PurchaseCallback {
            override fun onCompleted(
                storeTransaction: StoreTransaction,
                customerInfo: CustomerInfo,
            ) {
                deferred.complete(
                    object : PurchaseCompletion {
                        override var storeTransaction: StoreTransaction = storeTransaction
                        override var customerInfo: CustomerInfo = customerInfo
                    },
                )
            }

            override fun onError(
                error: PurchasesError,
                p1: Boolean,
            ) {
                deferred.completeExceptionally(PurchasesException(error))
            }
        },
    )
    return deferred.await()
}

suspend fun Purchases.awaitRestoration(): CustomerInfo {
    val deferred = CompletableDeferred<CustomerInfo>()
    restorePurchases(
        object : ReceiveCustomerInfoCallback {
            override fun onReceived(purchaserInfo: CustomerInfo) {
                deferred.complete(purchaserInfo)
            }

            override fun onError(error: PurchasesError) {
                deferred.completeExceptionally(error as Throwable)
            }
        },
    )
    return deferred.await()
}

class RevenueCatPurchaseController(
    val context: Context,
) : PurchaseController,
    UpdatedCustomerInfoListener {
    init {
        Purchases.logLevel = LogLevel.DEBUG
        Purchases.configure(
            PurchasesConfiguration
                .Builder(
                    context,
                    "android_rc_key",
                ).build(),
        )

        // Make sure we get the updates
        Purchases.sharedInstance.updatedCustomerInfoListener = this
    }

    fun syncSubscriptionStatus() {
        // Refetch the customer info on load
        Purchases.sharedInstance.getCustomerInfoWith {
            if (hasAnyActiveEntitlements(it)) {
                setSubscriptionStatus(
                    SubscriptionStatus.Active(
                        it.entitlements.active
                            .map {
                                Entitlement(it.key, Entitlement.Type.SERVICE_LEVEL)
                            }.toSet(),
                    ),
                )
            } else {
                setSubscriptionStatus(SubscriptionStatus.Inactive)
            }
        }
    }

    /**
     * Callback for rc customer updated info
     */
    override fun onReceived(customerInfo: CustomerInfo) {
        if (hasAnyActiveEntitlements(customerInfo)) {
            setSubscriptionStatus(
                SubscriptionStatus.Active(
                    customerInfo.entitlements.active
                        .map {
                            Entitlement(it.key, Entitlement.Type.SERVICE_LEVEL)
                        }.toSet(),
                ),
            )
        } else {
            setSubscriptionStatus(SubscriptionStatus.Inactive)
        }
    }

    /**
     * Initiate a purchase
     */
    override suspend fun purchase(
        activity: Activity,
        productDetails: ProductDetails,
        basePlanId: String?,
        offerId: String?,
    ): PurchaseResult {
        // Find products matching productId from RevenueCat
        val products = Purchases.sharedInstance.awaitProducts(listOf(productDetails.productId))
        // Choose the product which matches the given base plan.
        // If no base plan set, select first product or fail.
        val product =
            products.firstOrNull { it.googleProduct?.basePlanId == basePlanId }
                ?: products.firstOrNull()
                ?: return PurchaseResult.Failed("Product not found")

        return when (product.type) {
            ProductType.SUBS, ProductType.UNKNOWN ->
                handleSubscription(
                    activity,
                    product,
                    basePlanId,
                    offerId,
                )

            ProductType.INAPP -> handleInAppPurchase(activity, product)
        }
    }

    private fun buildSubscriptionOptionId(
        basePlanId: String?,
        offerId: String?,
    ): String =
        buildString {
            basePlanId?.let { append("$it") }
            offerId?.let { append(":$it") }
        }

    private suspend fun handleSubscription(
        activity: Activity,
        storeProduct: StoreProduct,
        basePlanId: String?,
        offerId: String?,
    ): PurchaseResult {
        storeProduct.subscriptionOptions?.let { subscriptionOptions ->
            // If subscription option exists, concatenate base + offer ID.
            val subscriptionOptionId = buildSubscriptionOptionId(basePlanId, offerId)

            // Find first subscription option that matches the subscription option ID or default
            // to letting revenuecat choose.
            val subscriptionOption =
                subscriptionOptions.firstOrNull { it.id == subscriptionOptionId }
                    ?: subscriptionOptions.defaultOffer

            // Purchase subscription option, otherwise fail.
            if (subscriptionOption != null) {
                return purchaseSubscription(activity, subscriptionOption)
            }
        }
        return PurchaseResult.Failed("Valid subscription option not found for product.")
    }

    private suspend fun purchaseSubscription(
        activity: Activity,
        subscriptionOption: SubscriptionOption,
    ): PurchaseResult {
        val deferred = CompletableDeferred<PurchaseResult>()
        Purchases.sharedInstance.purchaseWith(
            PurchaseParams.Builder(activity, subscriptionOption).build(),
            onError = { error, userCancelled ->
                deferred.complete(
                    if (userCancelled) {
                        PurchaseResult.Cancelled()
                    } else {
                        PurchaseResult.Failed(
                            error.message,
                        )
                    },
                )
            },
            onSuccess = { _, _ ->
                deferred.complete(PurchaseResult.Purchased())
            },
        )
        return deferred.await()
    }

    private suspend fun handleInAppPurchase(
        activity: Activity,
        storeProduct: StoreProduct,
    ): PurchaseResult =
        try {
            Purchases.sharedInstance.awaitPurchase(activity, storeProduct)
            PurchaseResult.Purchased()
        } catch (e: PurchasesException) {
            when (e.purchasesError.code) {
                PurchasesErrorCode.PurchaseCancelledError -> PurchaseResult.Cancelled()
                else ->
                    PurchaseResult.Failed(
                        e.message ?: "Purchase failed due to an unknown error",
                    )
            }
        }

    /**
     * Restore purchases
     */
    override suspend fun restorePurchases(): RestorationResult {
        try {
            if (hasAnyActiveEntitlements(Purchases.sharedInstance.awaitRestoration())) {
                return RestorationResult.Restored()
            } else {
                return RestorationResult.Failed(Exception("No active entitlements"))
            }
        } catch (e: Throwable) {
            return RestorationResult.Failed(e)
        }
    }

    /**
     * Check if the customer has any active entitlements
     */
    private fun hasAnyActiveEntitlements(customerInfo: CustomerInfo): Boolean {
        val entitlements =
            customerInfo.entitlements.active.values
                .map { it.identifier }
        return entitlements.isNotEmpty()
    }

    private fun setSubscriptionStatus(subscriptionStatus: SubscriptionStatus) {
        if (Superwall.initialized) {
            Superwall.instance.setSubscriptionStatus(subscriptionStatus)
        }
    }
}
```
:::

:::flutter
```dart
import 'dart:io';

import 'package:flutter/services.dart';
import 'package:purchases_flutter/purchases_flutter.dart';
import 'package:superwallkit_flutter/superwallkit_flutter.dart' hide LogLevel;

class RCPurchaseController extends PurchaseController {
  // MARK: Configure and sync subscription Status
  /// Makes sure that Superwall knows the customers subscription status by
  /// changing `Superwall.shared.subscriptionStatus`
  Future<void> configureAndSyncSubscriptionStatus() async {
    // Configure RevenueCat
    await Purchases.setLogLevel(LogLevel.debug);
    final configuration = Platform.isIOS
        ? PurchasesConfiguration('ios_rc_key')
        : PurchasesConfiguration('android_rc_key');
    await Purchases.configure(configuration);

    // Listen for changes
    Purchases.addCustomerInfoUpdateListener((customerInfo) async {
      // Gets called whenever new CustomerInfo is available
      final entitlements = customerInfo.entitlements.active.keys
          .map((id) => Entitlement(id: id))
          .toSet();

      final hasActiveEntitlementOrSubscription = customerInfo
          .hasActiveEntitlementOrSubscription(); // Why? -> https://www.revenuecat.com/docs/entitlements#entitlements

      if (hasActiveEntitlementOrSubscription) {
        await Superwall.shared.setSubscriptionStatus(
            SubscriptionStatusActive(entitlements: entitlements));
      } else {
        await Superwall.shared
            .setSubscriptionStatus(SubscriptionStatusInactive());
      }
    });
  }

  // MARK: Handle Purchases

  /// Makes a purchase from App Store with RevenueCat and returns its
  /// result. This gets called when someone tries to purchase a product on
  /// one of your paywalls from iOS.
  @override
  Future<PurchaseResult> purchaseFromAppStore(String productId) async {
    // Find products matching productId from RevenueCat
    final products = await PurchasesAdditions.getAllProducts([productId]);

    // Get first product for product ID (this will properly throw if empty)
    final storeProduct = products.firstOrNull;

    if (storeProduct == null) {
      return PurchaseResult.failed(
          'Failed to find store product for $productId');
    }

    final purchaseResult = await _purchaseStoreProduct(storeProduct);
    return purchaseResult;
  }

  /// Makes a purchase from Google Play with RevenueCat and returns its
  /// result. This gets called when someone tries to purchase a product on
  /// one of your paywalls from Android.
  @override
  Future<PurchaseResult> purchaseFromGooglePlay(
      String productId, String? basePlanId, String? offerId) async {
    // Find products matching productId from RevenueCat
    List<StoreProduct> products =
        await PurchasesAdditions.getAllProducts([productId]);

    // Choose the product which matches the given base plan.
    // If no base plan set, select first product or fail.
    String storeProductId = "$productId:$basePlanId";

    // Try to find the first product where the googleProduct's basePlanId matches the given basePlanId.
    StoreProduct? matchingProduct;

    // Loop through each product in the products list.
    for (final product in products) {
      // Check if the current product's basePlanId matches the given basePlanId.
      if (product.identifier == storeProductId) {
        // If a match is found, assign this product to matchingProduct.
        matchingProduct = product;
        // Break the loop as we found our matching product.
        break;
      }
    }

    // If a matching product is not found, then try to get the first product from the list.
    StoreProduct? storeProduct =
        matchingProduct ?? (products.isNotEmpty ? products.first : null);

    // If no product is found (either matching or the first one), return a failed purchase result.
    if (storeProduct == null) {
      return PurchaseResult.failed("Product not found");
    }

    switch (storeProduct.productCategory) {
      case ProductCategory.subscription:
        SubscriptionOption? subscriptionOption =
            await _fetchGooglePlaySubscriptionOption(
                storeProduct, basePlanId, offerId);
        if (subscriptionOption == null) {
          return PurchaseResult.failed(
              "Valid subscription option not found for product.");
        }
        return await _purchaseSubscriptionOption(subscriptionOption);
      case ProductCategory.nonSubscription:
        return await _purchaseStoreProduct(storeProduct);
      case null:
        return PurchaseResult.failed("Unable to determine product category");
    }
  }

  Future<SubscriptionOption?> _fetchGooglePlaySubscriptionOption(
    StoreProduct storeProduct,
    String? basePlanId,
    String? offerId,
  ) async {
    final subscriptionOptions = storeProduct.subscriptionOptions;

    if (subscriptionOptions != null && subscriptionOptions.isNotEmpty) {
      // Concatenate base + offer ID
      final subscriptionOptionId =
          _buildSubscriptionOptionId(basePlanId, offerId);

      // Find first subscription option that matches the subscription option ID or use the default offer
      SubscriptionOption? subscriptionOption;

      // Search for the subscription option with the matching ID
      for (final option in subscriptionOptions) {
        if (option.id == subscriptionOptionId) {
          subscriptionOption = option;
          break;
        }
      }

      // If no matching subscription option is found, use the default option
      subscriptionOption ??= storeProduct.defaultOption;

      // Return the subscription option
      return subscriptionOption;
    }

    return null;
  }

  Future<PurchaseResult> _purchaseSubscriptionOption(
      SubscriptionOption subscriptionOption) async {
    // Define the async perform purchase function
    // For versions of Flutter Purchases <9
    /*Future<CustomerInfo> performPurchase() async {
      // Attempt to purchase product
      CustomerInfo customerInfo =
          await Purchases.purchaseSubscriptionOption(subscriptionOption);
      return customerInfo;
    }*/
    // Flutter Purchases version 9+
    Future<CustomerInfo> performPurchase() async {
      // Attempt to purchase product
      final result = await Purchases.purchase(
        PurchaseParams.storeProduct(storeProduct),
      );
      return result.customerInfo;
    }


    PurchaseResult purchaseResult =
        await _handleSharedPurchase(performPurchase);
    return purchaseResult;
  }

  Future<PurchaseResult> _purchaseStoreProduct(
      StoreProduct storeProduct) async {
    // Define the async perform purchase function
    /* For Flutter Purchases <9
        Future<CustomerInfo> performPurchase() async {
      // Attempt to purchase product
      CustomerInfo customerInfo =
          await Purchases.purchaseStoreProduct(storeProduct);
      return customerInfo;
    }
    */

    // For flutter purchases 9+
    Future<CustomerInfo> performPurchase() async {
      // flutter_purchases 9+ API: use purchase(PurchaseParams) instead
      final result = await Purchases.purchase(
        PurchaseParams.storeProduct(storeProduct),
      );
    return result.customerInfo;
  }

    PurchaseResult purchaseResult =
        await _handleSharedPurchase(performPurchase);
    return purchaseResult;
  }

  // MARK: Shared purchase
  Future<PurchaseResult> _handleSharedPurchase(
      Future<CustomerInfo> Function() performPurchase) async {
    try {
      // Perform the purchase using the function provided
      CustomerInfo customerInfo = await performPurchase();

      // Handle the results
      if (customerInfo.hasActiveEntitlementOrSubscription()) {
        return PurchaseResult.purchased;
      } else {
        return PurchaseResult.failed("No active subscriptions found.");
      }
    } on PlatformException catch (e) {
      var errorCode = PurchasesErrorHelper.getErrorCode(e);
      if (errorCode == PurchasesErrorCode.paymentPendingError) {
        return PurchaseResult.pending;
      } else if (errorCode == PurchasesErrorCode.purchaseCancelledError) {
        return PurchaseResult.cancelled;
      } else {
        return PurchaseResult.failed(
            e.message ?? "Purchase failed in RCPurchaseController");
      }
    }
  }

  // MARK: Handle Restores

  /// Makes a restore with RevenueCat and returns `.restored`, unless an error is thrown.
  /// This gets called when someone tries to restore purchases on one of your paywalls.
  @override
  Future<RestorationResult> restorePurchases() async {
    try {
      await Purchases.restorePurchases();
      return RestorationResult.restored;
    } on PlatformException catch (e) {
      // Error restoring purchases
      return RestorationResult.failed(
          e.message ?? "Restore failed in RCPurchaseController");
    }
  }
}

// MARK: Helpers

String _buildSubscriptionOptionId(String? basePlanId, String? offerId) {
  String result = '';

  if (basePlanId != null) {
    result += basePlanId;
  }

  if (offerId != null) {
    if (basePlanId != null) {
      result += ':';
    }
    result += offerId;
  }

  return result;
}

extension CustomerInfoAdditions on CustomerInfo {
  bool hasActiveEntitlementOrSubscription() {
    return (activeSubscriptions.isNotEmpty || entitlements.active.isNotEmpty);
  }
}

extension PurchasesAdditions on Purchases {
  static Future<List<StoreProduct>> getAllProducts(
      List<String> productIdentifiers) async {
    final subscriptionProducts = await Purchases.getProducts(productIdentifiers,
        productCategory: ProductCategory.subscription);
    final nonSubscriptionProducts = await Purchases.getProducts(
        productIdentifiers,
        productCategory: ProductCategory.nonSubscription);
    final combinedProducts = [
      ...subscriptionProducts,
      ...nonSubscriptionProducts
    ];
    return combinedProducts;
  }
}
```
:::

:::expo

```tsx
import { Platform } from "react-native";
import { CustomPurchaseControllerProvider, SuperwallProvider } from "expo-superwall";
import Purchases, { PRODUCT_CATEGORY } from "react-native-purchases";
import { useEffect } from "react";

// Configure RevenueCat
function useRevenueCatSetup() {
  useEffect(() => {
    Purchases.setLogLevel(Purchases.LOG_LEVEL.DEBUG);
    const apiKey = Platform.OS === 'ios' ? 'ios_rc_key' : 'android_rc_key';
    Purchases.configure({ apiKey });

    // Listen for subscription status changes
    Purchases.addCustomerInfoUpdateListener((customerInfo) => {
      const entitlementIds = Object.keys(customerInfo.entitlements.active);
      console.log("Active entitlements:", entitlementIds);
      // Subscription status is automatically synced by Superwall
    });
  }, []);
}

export default function App() {
  useRevenueCatSetup();

  const purchaseController = {
    onPurchase: async (params) => {
      try {
        // Get products from RevenueCat
        const products = await (params.platform === 'ios'
          ? Purchases.getProducts([params.productId], PRODUCT_CATEGORY.SUBSCRIPTION)
          : Purchases.getProducts([params.productId], PRODUCT_CATEGORY.SUBSCRIPTION)
        );

        const product = products[0];
        if (product) {
          // Purchase through RevenueCat
          await Purchases.purchaseStoreProduct(product);
        } else {
          throw new Error(`Product not found: ${params.productId}`);
        }
      } catch (error) {
        console.error("Purchase failed:", error);
        throw error;
      }
    },
    onPurchaseRestore: async () => {
      try {
        await Purchases.restorePurchases();
      } catch (error) {
        console.error("Restore failed:", error);
        throw error;
      }
    },
  };

  return (
    <CustomPurchaseControllerProvider controller={purchaseController}>
      <SuperwallProvider apiKeys={{ ios: "YOUR_SUPERWALL_API_KEY" }}>
        {/* Your app content */}
      </SuperwallProvider>
    </CustomPurchaseControllerProvider>
  );
}
```
:::

As discussed in [Purchases and Subscription Status](/docs/advanced-configuration), this `CustomPurchaseControllerProvider` is responsible for handling the subscription-related logic using the modern hooks-based approach.

### 2. Configure Superwall (Continued)

The example above shows the complete setup. The `CustomPurchaseControllerProvider` wraps your `SuperwallProvider` and handles all purchase and restore logic through RevenueCat.

For more advanced implementations, see the [example app](https://github.com/superwall/expo-superwall/tree/main/example).

<Note>
**Legacy Approach**: If you're migrating from the old SDK or need the class-based purchase controller, you can use `expo-superwall/compat`. However, we recommend using the modern `CustomPurchaseControllerProvider` approach shown above.
</Note>

### Removed Legacy Code Section

The following section contains the legacy class-based approach. Skip to the next section for the modern configuration.

:::expo
```typescript
// LEGACY APPROACH - Use CustomPurchaseControllerProvider instead (see above)
import { Platform } from "react-native"
import Superwall, {
  PurchaseController,
  PurchaseResult,
  RestorationResult,
  SubscriptionStatus,
  PurchaseResultCancelled,
  PurchaseResultFailed,
  PurchaseResultPending,
  PurchaseResultPurchased,
} from 'expo-superwall/compat';
import Purchases, {
  type CustomerInfo,
  PRODUCT_CATEGORY,
  type PurchasesStoreProduct,
  type SubscriptionOption,
  PURCHASES_ERROR_CODE,
  type MakePurchaseResult,
} from "react-native-purchases"

export class RCPurchaseController extends PurchaseController {
  constructor() {
    super()

    Purchases.setLogLevel(Purchases.LOG_LEVEL.DEBUG);
    const apiKey = Platform.OS === 'ios' ? 'ios_rc_key' : 'android_rc_key';
    Purchases.configure({ apiKey });
  }

  syncSubscriptionStatus() {
    // Listen for changes
    Purchases.addCustomerInfoUpdateListener((customerInfo) => {
      const entitlementIds = Object.keys(customerInfo.entitlements.active)
      Superwall.shared.setSubscriptionStatus(
        entitlementIds.length === 0
          ? SubscriptionStatus.Inactive()
          : SubscriptionStatus.Active(entitlementIds)
      )
    })
  }

  async purchaseFromAppStore(productId: string): Promise<PurchaseResult> {
    const products = await Promise.all([
      Purchases.getProducts([productId], PRODUCT_CATEGORY.SUBSCRIPTION),
      Purchases.getProducts([productId], PRODUCT_CATEGORY.NON_SUBSCRIPTION),
    ]).then((results) => results.flat())

    // Assuming an equivalent for Dart's firstOrNull is not directly available in TypeScript,
    // so using a simple conditional check
    const storeProduct = products.length > 0 ? products[0] : null

    if (!storeProduct) {
      return new PurchaseResultFailed("Failed to find store product for $productId")
    }

    return await this._purchaseStoreProduct(storeProduct)
  }

  async purchaseFromGooglePlay(
    productId: string,
    basePlanId?: string,
    offerId?: string
  ): Promise<PurchaseResult> {
    // Find products matching productId from RevenueCat
    const products = await Promise.all([
      Purchases.getProducts([productId], PRODUCT_CATEGORY.SUBSCRIPTION),
      Purchases.getProducts([productId], PRODUCT_CATEGORY.NON_SUBSCRIPTION),
    ]).then((results) => results.flat())

    // Choose the product which matches the given base plan.
    // If no base plan set, select first product or fail.
    const storeProductId = `${productId}:${basePlanId}`

    // Initialize matchingProduct as null explicitly
    let matchingProduct: PurchasesStoreProduct | null = null

    // Loop through each product in the products array
    for (const product of products) {
      // Check if the current product's identifier matches the given storeProductId
      if (product.identifier === storeProductId) {
        // If a match is found, assign this product to matchingProduct
        matchingProduct = product
        // Break the loop as we found our matching product
        break
      }
    }

    let storeProduct: PurchasesStoreProduct | null =
      matchingProduct ??
      (products.length > 0 && typeof products[0] !== "undefined" ? products[0] : null)

    // If no product is found (either matching or the first one), return a failed purchase result.
    if (storeProduct === null) {
      return new PurchaseResultFailed("Product not found")
    }

    switch (storeProduct.productCategory) {
      case PRODUCT_CATEGORY.SUBSCRIPTION:
        const subscriptionOption = await this._fetchGooglePlaySubscriptionOption(
          storeProduct,
          basePlanId,
          offerId
        )
        if (subscriptionOption === null) {
          return new PurchaseResultFailed("Valid subscription option not found for product.")
        }
        return await this._purchaseSubscriptionOption(subscriptionOption)
      case PRODUCT_CATEGORY.NON_SUBSCRIPTION:
        return await this._purchaseStoreProduct(storeProduct)
      default:
        return new PurchaseResultFailed("Unable to determine product category")
    }
  }

  private async _purchaseStoreProduct(
    storeProduct: PurchasesStoreProduct
  ): Promise<PurchaseResult> {
    const performPurchase = async (): Promise<MakePurchaseResult> => {
      // Attempt to purchase product
      const makePurchaseResult = await Purchases.purchaseStoreProduct(storeProduct)
      return makePurchaseResult
    }
    return await this.handleSharedPurchase(performPurchase)
  }

  private async _fetchGooglePlaySubscriptionOption(
    storeProduct: PurchasesStoreProduct,
    basePlanId?: string,
    offerId?: string
  ): Promise<SubscriptionOption | null> {
    const subscriptionOptions = storeProduct.subscriptionOptions

    if (subscriptionOptions && subscriptionOptions.length > 0) {
      // Concatenate base + offer ID
      const subscriptionOptionId = this.buildSubscriptionOptionId(basePlanId, offerId)

      // Find first subscription option that matches the subscription option ID or use the default offer
      let subscriptionOption: SubscriptionOption | null = null

      // Search for the subscription option with the matching ID
      for (const option of subscriptionOptions) {
        if (option.id === subscriptionOptionId) {
          subscriptionOption = option
          break
        }
      }

      // If no matching subscription option is found, use the default option
      subscriptionOption = subscriptionOption ?? storeProduct.defaultOption

      // Return the subscription option
      return subscriptionOption
    }

    return null
  }

  private buildSubscriptionOptionId(basePlanId?: string, offerId?: string): string {
    let result = ""

    if (basePlanId !== null) {
      result += basePlanId
    }

    if (offerId !== null) {
      if (basePlanId !== null) {
        result += ":"
      }
      result += offerId
    }

    return result
  }

  private async _purchaseSubscriptionOption(
    subscriptionOption: SubscriptionOption
  ): Promise<PurchaseResult> {
    // Define the async perform purchase function
    const performPurchase = async (): Promise<MakePurchaseResult> => {
      // Attempt to purchase product
      const purchaseResult = await Purchases.purchaseSubscriptionOption(subscriptionOption)
      return purchaseResult
    }

    const purchaseResult: PurchaseResult = await this.handleSharedPurchase(performPurchase)
    return purchaseResult
  }

  private async handleSharedPurchase(
    performPurchase: () => Promise<MakePurchaseResult>
  ): Promise<PurchaseResult> {
    try {
      // Perform the purchase using the function provided
      const makePurchaseResult = await performPurchase()

      // Handle the results
      if (this.hasActiveEntitlementOrSubscription(makePurchaseResult.customerInfo)) {
        return new PurchaseResultPurchased()
      } else {
        return new PurchaseResultFailed("No active subscriptions found.")
      }
    } catch (e: any) {
      // Catch block to handle exceptions, adjusted for TypeScript
      if (e.userCancelled) {
        return new PurchaseResultCancelled()
      }
      if (e.code === PURCHASES_ERROR_CODE.PAYMENT_PENDING_ERROR) {
        return new PurchaseResultPending()
      } else {
        return new PurchaseResultFailed(e.message)
      }
    }
  }

  async restorePurchases(): Promise<RestorationResult> {
    try {
      await Purchases.restorePurchases()
      return RestorationResult.restored()
    } catch (e: any) {
      return RestorationResult.failed(e.message)
    }
  }

  private hasActiveEntitlementOrSubscription(customerInfo: CustomerInfo): Boolean {
    return (
      customerInfo.activeSubscriptions.length > 0 &&
      Object.keys(customerInfo.entitlements.active).length > 0
    )
  }
}
```
:::

As discussed in [Purchases and Subscription Status](/docs/advanced-configuration), this `PurchaseController` is responsible for handling the subscription-related logic. Take a few moments to look through the code to understand how it does this.

### 2. Configure Superwall

Initialize an instance of `RCPurchaseController` and pass it in to `Superwall.configure(apiKey:purchaseController)`:

:::ios
```swift
let purchaseController = RCPurchaseController()

Superwall.configure(
  apiKey: "MY_API_KEY",
  purchaseController: purchaseController
)
```
:::

:::android
```kotlin
val purchaseController = RCPurchaseController(this)

Superwall.configure(
  this,
  "MY_API_KEY",
  purchaseController
)

// Make sure we sync the subscription status
// on first load and whenever it changes
purchaseController.syncSubscriptionStatus()
```
:::

:::flutter
```dart
RCPurchaseController purchaseController = RCPurchaseController();

Superwall.configure(
  apiKey,
  purchaseController: purchaseController
);

await purchaseController.configureAndSyncSubscriptionStatus();
```
:::

:::expo
```tsx
// Modern approach with CustomPurchaseControllerProvider (see full example above)
import { CustomPurchaseControllerProvider, SuperwallProvider } from "expo-superwall";

export default function App() {
  const purchaseController = {
    onPurchase: async (params) => {
      // RevenueCat purchase logic
    },
    onPurchaseRestore: async () => {
      // RevenueCat restore logic
    },
  };

  return (
    <CustomPurchaseControllerProvider controller={purchaseController}>
      <SuperwallProvider apiKeys={{
        ios: "MY_SUPERWALL_IOS_API_KEY",
        android: "MY_SUPERWALL_ANDROID_API_KEY"
      }}>
        {/* Your app */}
      </SuperwallProvider>
    </CustomPurchaseControllerProvider>
  );
}
```
:::

### 3. Sync the subscription status

Then, call `purchaseController.syncSubscriptionStatus()` to keep Superwall's subscription status up to date with RevenueCat.

That's it! Check out our sample app for working examples:

:::ios
- [iOS](https://github.com/superwall/Superwall-iOS/tree/master/Examples/Advanced)
:::
:::android
- [Android](https://github.com/superwall/Superwall-Android/tree/develop/example/app/src/revenuecat)
:::
:::flutter
- [Flutter](https://github.com/superwall/Superwall-Flutter/blob/main/example/lib/RCPurchaseController.dart)
:::
:::expo
- [Expo](https://github.com/superwall/expo-superwall/tree/main/example)
- [React Native (deprecated)](https://github.com/superwall/react-native-superwall/blob/main/example/src/RCPurchaseController.tsx)
:::

## Using PurchasesAreCompletedBy

If you're using RevenueCat's [PurchasesAreCompletedBy](https://www.revenuecat.com/docs/migrating-to-revenuecat/sdk-or-not/finishing-transactions), you don't need to create a purchase controller. Register your placements, present a paywall â€” and Superwall will take care of completing any purchase the user starts. However, there are a few things to note if you use this setup:

1. Here, you aren't using RevenueCat's [entitlements](https://www.revenuecat.com/docs/getting-started/entitlements#entitlements) as a source of truth. If your app is multiplatform, you'll need to consider how to link up pro features or purchased products for users.
2. If you require custom logic when purchases occur, then you'll want to add a purchase controller. In that case, Superwall handles purchasing flows and RevenueCat will still observe transactions to power their analytics and charts.
3. Be sure that user identifiers are set the same way across Superwall and RevenueCat.

:::ios
Example:

```swift
Superwall.configure(apiKey: "superwall_public_key")
Superwall.shared.identify(userId: user.identifier)
Purchases.configure(with:
  .builder(withAPIKey: "revcat_public_key")
  .with(purchasesAreCompletedBy: .myApp, storeKitVersion: .storeKit1/.storeKit2)
  .with(appUserID: user.identifier)
  .build()
)
```
:::

For more information on observer mode, visit [RevenueCat's docs](https://www.revenuecat.com/docs/migrating-to-revenuecat/sdk-or-not/finishing-transactions).

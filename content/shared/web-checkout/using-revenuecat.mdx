---
title: "Using RevenueCat"
description: "Handle a deep link in your app and use the delegate methods to link web checkouts with RevenueCat."
---

After purchasing from a web paywall, the user will be redirected to your app by a deep link to redeem their purchase on device. Please follow our [Post-Checkout Redirecting](/web-checkout-post-checkout-redirecting) guide to handle this user experience.

<Note>
  If you're using Superwall to handle purchases, then you don't need to do anything here.
</Note>

<Warning>You only need to use a `PurchaseController` if you want end-to-end control of the purchasing pipeline. The recommended way to use RevenueCat with Superwall is by putting it in observer mode.</Warning>

If you're using your own `PurchaseController`, you should follow our [Redeeming In-App](/web-checkout-linking-membership-to-iOS-app) guide.

### Using a PurchaseController with RevenueCat

If you're using RevenueCat, you'll need to follow [steps 1 to 4 in their guide](https://www.revenuecat.com/docs/web/integrations/stripe) to set up Stripe with RevenueCat. Then, you'll need to
associate the RevenueCat customer with the Stripe subscription IDs returned from redeeming the code. You can do this by extracting the ids from the `RedemptionResult` and sending them to RevenueCat's API
by using the `didRedeemLink(result:)` delegate method:

```swift
import Foundation
import RevenueCat

final class Delegate: SuperwallDelegate {
  // The user tapped on a deep link to redeem a code
  func willRedeemLink() {
    print("[!] willRedeemLink")
    // Optionally show a loading indicator here
  }

  // Superwall received a redemption result and validated the purchase with Stripe.
  func didRedeemLink(result: RedemptionResult) {
    print("[!] didRedeemLink", result)
    // Send Stripe IDs to RevenueCat to link purchases to the customer

    // Get a list of subscription ids tied to the customer.
    guard let stripeSubscriptionIds = result.stripeSubscriptionIds else { return }
    guard let url = URL(string: "https://api.revenuecat.com/v1/receipts") else { return }

    let revenueCatStripePublicAPIKey = "strp....." // replace with your RevenueCat Stripe Public API Key
    let appUserId = Purchases.shared.appUserID

    // In the background...
    Task.detached {
      await withTaskGroup(of: Void.self) { group in
        // For each subscription id, link it to the user in RevenueCat
        for stripeSubscriptionId in stripeSubscriptionIds {
          group.addTask {
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.setValue("application/json", forHTTPHeaderField: "Accept")
            request.setValue("stripe", forHTTPHeaderField: "X-Platform")
            request.setValue("Bearer \(revenueCatStripePublicAPIKey)", forHTTPHeaderField: "Authorization")

            do {
              request.httpBody = try JSONEncoder().encode([
                "app_user_id": appUserId,
                "fetch_token": stripeSubscriptionId
              ])

              let (data, _) = try await URLSession.shared.data(for: request)
              let json = try JSONSerialization.jsonObject(with: data, options: [])
              print("[!] Success: linked \(stripeSubscriptionId) to user \(appUserId)", json)
            } catch {
              print("[!] Error: unable to link \(stripeSubscriptionId) to user \(appUserId)", error)
            }
          }
        }
      }

      /// After all network calls complete, invalidate the cache without switching to the main thread.
      Purchases.shared.getCustomerInfo(fetchPolicy: .fetchCurrent) { customerInfo, error in
        /// If you're using `Purchases.shared.customerInfoStream`, or keeping Superwall Entitlements in sync
        /// via RevenueCat's `PurchasesDelegate` methods, you don't need to do anything here. Those methods will be
        /// called automatically when this call fetches the most up to customer info, ignoring any local caches.

        /// Otherwise, if you're manually calling `Purchases.shared.getCustomerInfo`  to keep Superwall's entitlements
        /// in sync, you should use the newly updated customer info here to do so.
      }

      /// You could always access web entitlements here as well
      /// `let webEntitlements = Superwall.shared.entitlements.web`

      // After all network calls complete...
      await MainActor.run {
        // Perform UI updates on the main thread, like letting the user know their subscription was redeemed
      }
    }
  }
}
```

<Warning>
  If you call `logIn` from RevenueCat's SDK, then you need to call the logic you've implemented
  inside `didRedeemLink(result:)` again. For example, that means if `logIn` was invoked from
  RevenueCat, you'd either abstract out this logic above into a function to call again, or simply
  call this function directly.
</Warning>

The web entitlements will be returned along with other existing entitlements in the `CustomerInfo` object accessible via RevenueCat's SDK.

If you’re logging in and out of RevenueCat, make sure to resend the Stripe subscription IDs to RevenueCat’s endpoint after logging in.
